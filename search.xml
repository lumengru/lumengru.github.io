<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[投资理财列表]]></title>
    <url>%2F2017%2F07%2F26%2F%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[理财QQ群: 662054784 群主是名程序员, 接触理财也有一段时间了,所以把这些平台分享出来,注意: 投资有风险,理财需谨慎,这里分享的是投资返现的, 当然群主会从中间抽取一些手续费,[手动笑脸],但是5000以内不收手续费 诚天财富(立即返现)这个平台运行两年了,群主通过天眼查,网站域名申请人等信息确定这个平台没有虚假信息 注意:立返的金额就是总收益, 到期平台只返回本金 返现金额一月标 1000立返73.88 一月标 5000立返370.00 一月标 1w立返650.00 约标 3w立返2200.00 约标 5w立返3800.00 约标 10万立返7900.00 做单流程 (本活动日期 到2017年8月6号) 注册（邀请码: cfc39ef01b2a6187）戳链接诚天财富 认证。根据页面要求，实名认证（无需上传身份证，填写正确的身份证号即可）。手机号码认证 充值。点击充值，填写将要投资的金额。可以选择e汇通(支持多种银行) 投资。进入首页，找到一个月标点击:立即投资。 交单。截图（需截到用户名和投标记录）, 支付宝帐号(用户收钱), 投资平台 注意：最少投资1000 ，任何银行卡都可以 ,投资有风险,理财需谨慎 财优优 (次日返现)财优优隶属上海晖先金融信息服务有限公司，注册资本1亿，双APP、微信端、PC网站同时上线，国企背景。全网唯数不多的高返、安全、稳健的 爆款大毛, 本月已递交银行存管资料 8月份正式签署银行存管协议 返现金额 500档：收益：返现25+利息3.4+红包6+体验金7=41.4 1000档：收益：返现50+利息6.8+红包18+体验金7=80.8 5000档：收益：返现200+利息35+红包58+体验金7=300 1W档：收益：返现400+利息68+红包128+体验金7=603 5W档：收益：返现2300+利息342+红包308+体验金7=2957（限额10W） 做单流程 (本活动长期有效)电脑注册地址:https://www.caiyoyoo.com/user/register.html?channelCode=eXVsdWU=&amp;channelUsers=0011, 手机注册地址:https://mfin.caiyoyoo.com/mobile/user/register.html?channelCode=eXVsdWU=&amp;channelUsers=0011 交单格式 ：姓名、电话号码、投资金额、投资平台、支付宝帐号(用户收钱) 注意：仅仅首投有效(复投返3.8） 投资时 请注意勾选使用红包 新手体验金收益会自动放进优惠里面。]]></content>
      <categories>
        <category>投资理财</category>
      </categories>
      <tags>
        <tag>投资理财 平台列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-去掉多余的打印]]></title>
    <url>%2F2017%2F07%2F10%2FSwift-%E5%8E%BB%E6%8E%89%E5%A4%9A%E4%BD%99%E7%9A%84%E6%89%93%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[在我们开发过程中, 工具运行时控制台有许多关于网络相关的打印,非常烦人,我们可以选择屏蔽掉这些打印 屏蔽多余的打印选择Product-&gt;Scheme-&gt;Edit Scheme …或者直接按 command + shift + &lt; 快捷键，在弹出的窗口中Environment Variables 下添加 name为OS_ACTIVITY_MODE, value为disable 如图 发布时取消打印,自定义打印代码 OC代码 12345#ifndef DEBUG_MODE #define DLog( s, ... ) NSLog( @"&lt;%p %@:(%d)&gt; %@", self, [[NSString stringWithUTF8String:__FILE__] lastPathComponent], __LINE__, [NSString stringWithFormat:(s), ##__VA_ARGS__] ) #else #define DLog( s, ... ) #endif Swift代码 123456789func LMRLog&lt;T&gt;(message : T, file : String = #file, lineNumber : Int = #line) &#123; #if DEBUG let fileName = (file as NSString).lastPathComponent print("[\(fileName):line:\(lineNumber)]- \(message)") #endif&#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift 功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-后台语音播报]]></title>
    <url>%2F2017%2F06%2F23%2FiOS-%E5%90%8E%E5%8F%B0%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[公司要求需要做一个类似支付宝的收款的语音播报功能,研究了一天才完成,记录下来 写在前面语音播报功能的实现必须是推送加语音合成,选择的推送是极光推送,本文最终实现的效果即使APP被杀死也可以进行语音播报 实现 配置推送证书,极光文档里面有,把极光推送集成进去就不说了 语音合成我用的是系统的方法,不过语音死板不好听,但是使用很简单,3行代码就可以,建议使用其他的SDK 12345AVSpeechUtterance *utterance = [AVSpeechUtterance speechUtteranceWithString:@"成功集成语音播报"]; AVSpeechSynthesizer *synth = [[AVSpeechSynthesizer alloc] init]; [synth speakUtterance:utterance]; 在收到通知的时候使用上面的3行代码就可以进行语音播报,但是只限于APP前台运行,当后台运行的时候语音播报便不可以了,此时需要加入下面代码让语音播报可以在后台运行,但是杀死的情况下不能播报,杀死重新启动返回后台也不可以播报. 我是在AppDelegate里面写入这个方法的 1- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions; 把下面的代码写入进去 12345678910111213141516171819NSError *error = NULL; AVAudioSession *session = [AVAudioSession sharedInstance]; [session setCategory:AVAudioSessionCategoryPlayback error:&amp;error]; if(error) &#123; // Do some error handling &#125; [session setActive:YES error:&amp;error]; if (error) &#123; // Do some error handling&#125; // 让app支持接受远程控制事件[[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; 让语音播报在后台也可以进行的话就需要在 12345// 在AppDelegate定义属性@property (nonatomic, unsafe_unretained) UIBackgroundTaskIdentifier backgroundTaskIdentifier;- (void)applicationWillResignActive:(UIApplication *)application; 里面加入以下的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152- (void)applicationWillResignActive:(UIApplication *)application &#123; // 开启后台处理多媒体事件 [[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; AVAudioSession *session=[AVAudioSession sharedInstance]; [session setActive:YES error:nil]; // 后台播放 [session setCategory:AVAudioSessionCategoryPlayback error:nil]; // 这样做，可以在按home键进入后台后 ，播放一段时间，几分钟吧。但是不能持续播放网络歌曲，若需要持续播放网络歌曲，还需要申请后台任务id，具体做法是： _backgroundTaskIdentifier=[AppDelegate backgroundPlayerID:_backgroundTaskIdentifier]; // 其中的_bgTaskId是后台任务UIBackgroundTaskIdentifier _bgTaskId; &#125;//实现一下backgroundPlayerID:这个方法:+(UIBackgroundTaskIdentifier)backgroundPlayerID:(UIBackgroundTaskIdentifier)backTaskId&#123; //设置并激活音频会话类别 AVAudioSession *session=[AVAudioSession sharedInstance]; [session setCategory:AVAudioSessionCategoryPlayback error:nil]; [session setActive:YES error:nil]; //允许应用程序接收远程控制 [[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; //设置后台任务ID UIBackgroundTaskIdentifier newTaskId=UIBackgroundTaskInvalid; newTaskId=[[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:nil]; if(newTaskId!=UIBackgroundTaskInvalid&amp;&amp;backTaskId!=UIBackgroundTaskInvalid)&#123; [[UIApplication sharedApplication] endBackgroundTask:backTaskId]; &#125; return newTaskId; &#125; 到这里就可以进行后台播报了,但是注意 到这一步只有在程序没有被杀死的情况下才可以播报, 杀死之后是不能播报的, 所有我们还要进行处理,这时需要使用 UNNotificationServiceExtension. 创建 UNNotificationServiceExtension 填写文件名,边创建好了 在 NotificationService.m 里面有一个方法 1- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler; 此时把语音播报写进去就可以了 1234567891011121314151617181920- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler &#123; self.contentHandler = contentHandler; self.bestAttemptContent = [request.content mutableCopy]; // Modify the notification content here... self.bestAttemptContent.title = [NSString stringWithFormat:@"%@ [modified]", self.bestAttemptContent.title]; NSString *content = request.content.userInfo[@"aps"][@"alert"][@"body"]; AVSpeechUtterance *utterance = [AVSpeechUtterance speechUtteranceWithString:content]; AVSpeechSynthesizer *synth = [[AVSpeechSynthesizer alloc] init]; [synth speakUtterance:utterance]; self.contentHandler(self.bestAttemptContent);&#125; 认为到这里就完成了?,NO!在发送推送的时候还需要在极光推送服务里面配置一下 到这一步的时候,后台播报就可以执行了, 但是 此播报服务只能在 iOS10 系统之后才可以进行, 如果想适配iOS9之前的只能做一个固定的音频文件放到项目里面,比如支付宝的的到账提醒, 然后在推送的时候 这时候就可以完美播放音频文件了, 提醒: 如果不需要动态的语音播放, 直接可以使用这个方法,不需要配置 UNNotificationServiceExtension 和后台播放了,因为这个方法是系统认为推送的提示音]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS 功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-扩展方法]]></title>
    <url>%2F2017%2F06%2F12%2FSwift-%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在使用Swfit的过程中把各种方法扩展起来,方便用于开发,Swift3.0版本 扩展的写法 因为Swift 不需要在使用相应的头文件的时候引入头文件所以可以把这些扩展方法写到同一个文件中,这个是和OC的区别, 例子: 1234567891011// 扩展 String 类型extension String &#123;&#125;// 扩展UILabelextension UILabel &#123;&#125; 扩展String 获取字符串的高度 123456789101112131415func getTextHeight(font:CGFloat,width:CGFloat) -&gt; CGFloat &#123; let normalText = self as NSString let size = CGSize(width: width, height: CGFloat(MAXFLOAT)) let fontS = UIFont.systemFont(ofSize: font) let dic = NSDictionary(object: fontS, forKey: NSFontAttributeName as NSCopying) let stringSize = normalText.boundingRect(with: size, options: .usesLineFragmentOrigin, attributes: dic as? [String : AnyObject], context:nil).size return stringSize.height &#125; 获取字符串的长度 123456789101112131415func getTexWidth(font:CGFloat,height:CGFloat) -&gt; CGFloat &#123; let normalText: NSString = self as NSString let size = CGSize(width: CGFloat(MAXFLOAT), height: height) let fontS = UIFont.systemFont(ofSize: font) let dic = NSDictionary(object: fontS, forKey: NSFontAttributeName as NSCopying) let stringSize = normalText.boundingRect(with: size, options: .usesLineFragmentOrigin, attributes: dic as? [String : AnyObject], context:nil).size return stringSize.width &#125; MD5 加密 12345678910111213141516171819202122232425var md5 : String&#123; let str = self.cString(using: String.Encoding.utf8) let strLen = CUnsignedInt(self.lengthOfBytes(using: String.Encoding.utf8)) let digestLen = Int(CC_MD5_DIGEST_LENGTH) let result = UnsafeMutablePointer&lt;CUnsignedChar&gt;.allocate(capacity: digestLen) CC_MD5(str!, strLen, result) let hash = NSMutableString() for i in 0 ..&lt; digestLen &#123; hash.appendFormat("%02x", result[i]) &#125; result.deinitialize() return String(format: hash as String) &#125; 汉字转拼音(需要消耗不少性能,注意使用) 12345678910111213141516171819func transformToPinYin() -&gt; String &#123; let mutableString = NSMutableString(string: self) //把汉字转为拼音 CFStringTransform(mutableString, nil, kCFStringTransformToLatin, false) //去掉拼音的音标 CFStringTransform(mutableString, nil, kCFStringTransformStripDiacritics, false) let string = String(mutableString) //去掉空格 return string.replacingOccurrences(of: " ", with: "") &#125; 把这些方法全部放到下面的的代码里面,即可使用 12345// 扩展 String 类型 extension String &#123; &#125; 扩展UILabel 修改UILabel的行间距 12345678910111213func modifyTheLineSpacing(distance: CGFloat) &#123; let attributedString: NSMutableAttributedString = NSMutableAttributedString(string: self.text!) let paragraphStyle: NSMutableParagraphStyle = NSMutableParagraphStyle() paragraphStyle.lineSpacing = distance // 调整行间距 attributedString.addAttribute(NSParagraphStyleAttributeName, value: paragraphStyle, range: NSMakeRange(0, (self.text! as NSString).length)) self.attributedText = attributedString; &#125; 修改字体颜色 12345678910111213141516171819func changeTheTextColor(textColor: UIColor, textFont: CGFloat, range: NSRange) &#123; let attributedString: NSMutableAttributedString = NSMutableAttributedString(string: self.text!) let attris: [String: AnyObject] = [ NSForegroundColorAttributeName: textColor, NSFontAttributeName: UIFont.systemFont(ofSize: textFont), NSBackgroundColorAttributeName: self.backgroundColor! ] attributedString.addAttributes(attris, range: range) self.attributedText = attributedString; &#125; 把这些方法全部放到下面的的代码里面,即可使用 12345// 扩展 String 类型 extension UILabel &#123; &#125; 扩展UIView写在扩展前面,因为我比较喜欢使用Frame布局,没有使用Xib,SB等, 一开始使用布局的时候都是使用 1self.view.frame.size.with + self.view.frame.origin.x 这样布局, 写着很累,个人能力又有较大的提升的时候,对UIView进行扩展之后,想要和上面的代码拥有相同的效果便很简单了 1self.view.maxX 是不是很简单? 对UIView进行扩展 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475extension UIView &#123; // 获取view左边的坐标 var minX: CGFloat &#123; return self.frame.origin.x &#125; // 获取view右边的坐标 var maxX: CGFloat &#123; return self.frame.origin.x + self.frame.size.width &#125; // 获取view上边的坐标 var minY: CGFloat &#123; return self.frame.origin.y &#125; // 获取view下边的坐标 var maxY: CGFloat &#123; return self.frame.origin.y + self.frame.size.height &#125; // 获取view的x轴的中心点 var centerX: CGFloat &#123; return self.center.x &#125; // 获取view的y轴的中心点 var centerY: CGFloat &#123; return self.center.y &#125; // 获取view的宽度 var width: CGFloat &#123; return self.frame.size.width &#125; // 获取view的高度 var height: CGFloat &#123; return self.frame.size.height &#125; // 获取view的size var size: CGSize &#123; return self.frame.size &#125;&#125; 使用方法很简单,比如 1234567//获取View的高度self.view.height//获取View的宽度self.view.width 扩展UIImage123456789101112131415161718192021222324252627extension UIImage&#123; // 重设图片大小 func changeImageSize(size:CGSize) -&gt; UIImage &#123; UIGraphicsBeginImageContextWithOptions(size,false,UIScreen.main.scale); self.draw(in: CGRect(x: 0, y: 0, width: size.width, height: size.height)) let resizeImage: UIImage = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext(); return resizeImage; &#125; // 等比例缩放 func scaleImage(scaleSize:CGFloat) -&gt; UIImage &#123; let reSize = CGSize(width: self.size.width * scaleSize, height: self.size.height * scaleSize) return changeImageSize(size: reSize) &#125; &#125; 扩展UIColor当设计师给的16进制颜色的时候便可以调用下面的方法 1234567891011121314151617181920212223242526272829303132333435363738extension UIColor &#123; convenience init(hexString: String) &#123; // 存储转换后的数值 var red:UInt32 = 0, green:UInt32 = 0, blue:UInt32 = 0 // 分别转换进行转换 Scanner(string: hexString[0..&lt;2]).scanHexInt32(&amp;red) Scanner(string: hexString[2..&lt;4]).scanHexInt32(&amp;green) Scanner(string: hexString[4..&lt;6]).scanHexInt32(&amp;blue) self.init(red: CGFloat(red)/255.0, green: CGFloat(green)/255.0, blue: CGFloat(blue)/255.0, alpha: 1.0) &#125; convenience init(hexString: String, alpha: CGFloat) &#123; // 存储转换后的数值 var red:UInt32 = 0, green:UInt32 = 0, blue:UInt32 = 0 // 分别转换进行转换 Scanner(string: hexString[0..&lt;2]).scanHexInt32(&amp;red) Scanner(string: hexString[2..&lt;4]).scanHexInt32(&amp;green) Scanner(string: hexString[4..&lt;6]).scanHexInt32(&amp;blue) self.init(red: CGFloat(red)/255.0, green: CGFloat(green)/255.0, blue: CGFloat(blue)/255.0, alpha: alpha) &#125; &#125; 使用方法 1imageView.backgroundColor = UIColor(hexString: "eeeeee") 扩展 提示框 UIAlertController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748extension UIAlertController &#123; class func createUIAlertController(title: String?, message: String?, leftButton: String, rightButton: String, complete: @escaping () -&gt; Void) -&gt; UIAlertController&#123; let av = UIAlertController(title: title, message: message, preferredStyle: .alert) let cancel = UIAlertAction(title: leftButton, style: .cancel, handler: nil) let confirm = UIAlertAction(title: rightButton, style: .destructive, handler: &#123; (action) in complete() &#125;) av.addAction(cancel) av.addAction(confirm) return av &#125; class func createUIAlertController(title: String?, message: String?, leftButton: String, rightButton: String, cancel: @escaping() -&gt; Void, complete: @escaping () -&gt; Void) -&gt; UIAlertController&#123; let av = UIAlertController(title: title, message: message, preferredStyle: .alert) let cancel = UIAlertAction(title: leftButton, style: .cancel) &#123; (action) in cancel() &#125; let confirm = UIAlertAction(title: rightButton, style: .destructive, handler: &#123; (action) in complete() &#125;) av.addAction(cancel) av.addAction(confirm) return av &#125;&#125; 使用方法 12345678910self.present(UIAlertController.createUIAlertController(title: "提示", message: "扩展到这里就结束了", leftButton: "取消", rightButton: "确定", cancel: &#123; // 点击取消的按钮 &#125;, complete: &#123; // 点击确定的按钮 &#125;) , animated: true, completion: nil)]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift 功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-静态库的打包]]></title>
    <url>%2F2017%2F06%2F11%2FiOS-%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[这段时间公司需要把一个工程里的代码抽出来制作成静态库, 所以就研究了一下怎么打包静态库 一些概念的补充 什么是库？ 所谓库就是程序代码的集合，是共享程序代码的一种方式。 库的分类 根据程序代码的开源情况，库可以分为两类 开源库 源代码是公开的，你可以看到具体实现。比如GitHub上比较出名的第三方框架AFNetworking、SDWebImage。 闭源库 不公开源代码，只公开调用的接口，看不到具体的实现，是一个编译后的二进制文件。这种常见于一些公司的SDK包，比如高德地图SDK、环信即时通讯SDK等等。而闭源库又分为两类：静态库和动态库。本篇重点要讲的便是其中的静态库。 3、静态库和动态库的存在形式和使用区别 存在形式： 静态库 以”.a”或者“.framework”为文件后缀名 动态库 以”.dylib”或者“.framework”为文件后缀名 使用区别： 静态库链接时会被完整的复制到可执行文件中，被多次使用就有多份拷贝。 动态库链接时不复制，程序运行时由系统动态加载到内存，供程序调用。而且系统只加载一次，多个程序共用，节省内存。 .a文件静态库打包 打开Xcode创建一个新的工程，这里以Xcode8为例，选择工程如下： 把需要打包的文件放入到根目录里面(注意是根目录) 自动生成的 .h 和 .m 文件可以删除 公开接口或者头文件供人调用 targets-&gt;Build Phases-&gt;Copy Files-&gt;”+”你需要公开的头文件 静态库也分为 Debug 和 Release 这里我们可以直接选择 Release 选择编译设备(真机 或者 模拟器) 注: 真机打包的只能在真机上运行, 模拟器打包的只能在模拟器上运行, 不然会报错, 可以在真机上打一个包, 模拟器上打一个包 然后合并. 此时需要配置的都已经完成按住 cmd+B 编译成功之后可以看到 Products 文件夹里面的 .a 文件从红色变成黑色(注: 可能不会改变颜色, 可以关闭 Xcode 重新打开, 此时颜色应该改变了,不改变也没有关系!!!) 选中文件点击 Show in Finder 此时文件里面有个 .a 文件 和 一个文件夹如果要使用这个的话需要把两个文件全部放到工程文件里面 .framework文件静态库打包 和 .a 文件的创建一样 直接把需要打包的代码放到根目录里面, 不同的是 自动生成的.h 文件不用删除 (注: 可以把需要暴露出来的多个头文件放到这个.h文件中,到时只要引用这一次头文件就OK了) 把需要暴露出来的头文件写入到.h文件里面,写法&lt;工程名/头文件.h&gt; 暴露头文件,和 .a 文件不同的是 .framework文件是在 Headers 里面暴露出来 和 .a文件一样,.frmeworke静态库也分为 Debug 和 Release 这里我们可以直接选择 Release 设置打包的是静态库。因为动态库也可以是以framework形式存在，所以需要设置，否则默认打出来的是动态库 target-&gt;BuildSetting -&gt;搜索关键字mach-&gt;Mach-o Type 设为Static Library（这个默认选项是动态的） 和.a文件一样, .framework 也分为真机运行 和模拟器运行, 所以 真机运行一次, 模拟器运行一次, 然后合并 双击.framework 文件,可以看到 把SDK合并完成之后,直接替换掉.framework 文件里面的SDK文件就可以了 静态库适配Bitcode在我第一次打包成功之后,使用静态库,在运行在真机 模拟器没有任何错误,然后打包工程的时候,报错了,错误信息是没有适配Bitcode 第一件事是在Target-&gt;Build Settings-&gt;Build Options中开启Enable BitCode. 然后去Target-&gt;Build Settings-&gt;Custom Compiler Flags中加入-fembed-bitcode。 如图: 静态库合并 让工程在真机和模拟器上各运行一次, 然后点击 Show in Finder 选择文件夹 分栏展示, 可以看到文件的上一级有两个文件夹 Release-iphoneos 和 Release-iphonesimulator 对这两个.a文件进行合并: 打开终端 在终端里面执行 1lipo -create 第一个.a文件的绝对路径 第二个.a文件的绝对路径 -output 最终的.a文件路径。 本文中使用的命令如下: 12345lipo -create /Users/harvey/Library/Developer/Xcode/DerivedData/FMDB-ctegiztcjikewoeprxxtmryzetfa/Build/Products/Release-iphoneos/libFMDB.a /Users/harvey/Library/Developer/Xcode/DerivedData/FMDB-ctegiztcjikewoeprxxtmryzetfa/Build/Products/Release-iphonesimulator/libFMDB.a -output /Users/harvey/Desktop/libFMDB.a 静态库的使用 .a静态库的使用 把打包生成的 .a 文件 和 暴露出来的头文件 及 使用的其他资源(例: 图片, 音频…) 拖入到工程中, 然后在使用的地方导入暴露出来的相应的头文件即可. .framework 静态库的使用 直接把打包好的静态块拖入进工程里面, 在相应的地方引入头文件,用尖括号包起来 例: 1#import &lt;LinkPayLoanSDK/LinkPayLoanSDK.h&gt; Bundel 文件Bundel文件是什么 什么是Bundle文件？ 简单理解，就是资源文件包。我们将许多图片、XIB、文本文件组织在一起，打包成一个Bundle文件。方便在其他项目中引用包内的资源。 Bundle文件的特点？ Bundle是静态的，也就是说，我们包含到包中的资源文件作为一个资源包是不参加项目编译的。也就意味着，bundle包中不能包含可执行的文件。它仅仅是作为资源，被解析成为特定的2进制数据。 Bundle文件制作直接在桌面新建一个文件夹然后把后缀名改为 .bundle 就可以了, 向里面放文件的时候直接双击打开,然后把文件拖入进去 Bundle文件使用把生成的.bundle文件拖入工程中, 使用规则: Bundle文件名称.bundle/资源名称,例: 1[UIImage imageNamed:@"LinkPayBundle.bundle/LinkPaySDKback"]]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS 功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-时间戳]]></title>
    <url>%2F2017%2F05%2F31%2FSwift-%E6%97%B6%E9%97%B4%E6%88%B3%2F</url>
    <content type="text"><![CDATA[时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。 获取现在的时间戳(秒)12345678910111213func getNowDataString() -&gt; String &#123; // 当前的时间 例如 "May 31, 2017, 10:43 AM" let date:NSDate = NSDate() // 把时间转换成时间戳 例如 1496198622.22576 let time: TimeInterval = date.timeIntervalSince1970 return String(format: "%.0f", time) &#125; 根据时间戳 和 指定的时间格式来返回时间 (秒)12345678910111213141516171819func yearsMonthDay(time: NSNumber, format: String) -&gt; String &#123; // yyyy-MM-dd HH:mm:ss //转换为时间 let timeInterval:TimeInterval = TimeInterval(Int(time)) let date = Date(timeIntervalSince1970: timeInterval) //格式话输出 let dformatter = DateFormatter() dformatter.dateFormat = format return dformatter.string(from: date)&#125; 时间戳转换时间 (秒)1234567891011121314151617func dateFrom(time: String, format: String) -&gt; String &#123; //格式话输出 let dfmatter = DateFormatter() dfmatter.dateFormat = format let date = dfmatter.date(from: time) let dateStamp:TimeInterval = date!.timeIntervalSince1970 let dateSt:Int = Int(dateStamp) return String(dateSt) &#125; 时间格式123456789101112131415161718192021G: 公元时代，例如AD公元yy: 年的后2位yyyy: 完整年MM: 月，显示为1-12,带前置0MMM: 月，显示为英文月份简写,如 JanMMMM: 月，显示为英文月份全称，如 Janualydd: 日，2位数表示，如02d: 日，1-2位显示，如2，无前置0EEE: 简写星期几，如SunEEEE: 全写星期几，如Sundayaa: 上下午，AM/PMH: 时，24小时制，0-23HH: 时，24小时制，带前置0h: 时，12小时制，无前置0hh: 时，12小时制，带前置0m: 分，1-2位mm: 分，2位，带前置0s: 秒，1-2位ss: 秒，2位，带前置0S: 毫秒Z： GMT（时区）]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift 功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-把事件写入到日历中]]></title>
    <url>%2F2017%2F05%2F31%2FSwift-%E6%8A%8A%E4%BA%8B%E4%BB%B6%E5%86%99%E5%85%A5%E5%88%B0%E6%97%A5%E5%8E%86%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[把APP事件写入到苹果软件日历中 事件添加 导入头文件 import EventKit 创建 EKEventStore类型的实例eventStore 以及事件的id eventIdentifier 获取请求权限 12345678910111213141516171819202122var eventStore: EKEventStore! eventStore.requestAccess(to: .event) &#123; (success, error) in if error != nil &#123; // 错误中心 print(error ?? "") &#125;else if !success &#123; // 用户被拒绝 print(error ?? "") &#125;else&#123; // 创建事件 &#125; &#125; 在else里面创建事件 123456789101112131415161718192021222324252627282930313233343536373839let event: EKEvent = EKEvent(eventStore: self.eventStore) event.title = "您今天该还款了,借贷宝 1000元" event.location = "我在上海浦东软件园" // 开始时间 应该传入时间戳 event.startDate = self.dateFrom(time: "2017-05-27 11:37:00", format: "yyyy-MM-dd HH:mm:ss") // 结束时间 时间到了 该事件从日历中消失 event.endDate = self.dateFrom(time: "2017-05-27 11:38:00", format: "yyyy-MM-dd HH:mm:ss") // 提醒时间 按照秒来计算 event.addAlarm(EKAlarm(relativeOffset: -10)) event.addAlarm(EKAlarm(relativeOffset: -30)) event.addAlarm(EKAlarm(relativeOffset: -50)) event.calendar = self.eventStore.defaultCalendarForNewEvents do &#123; // 事件添加成功 try self.eventStore.save(event, span: .thisEvent) print(event.eventIdentifier) self.eventIdentifier = event.eventIdentifier &#125; catch &#123; print("有坏银！") &#125; 事件删除 根据之前获取的id “eventIdentifier” 123456789101112131415let eventToRemove = eventStore.event(withIdentifier: eventIdentifier!) if (eventToRemove != nil) &#123; do &#123; try eventStore.remove(eventToRemove!, span: .thisEvent) &#125; catch &#123; print("Bad things happened") &#125; &#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift 功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向传值]]></title>
    <url>%2F2016%2F11%2F28%2F%E9%80%86%E5%90%91%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[用代理和闭包进行逆向传值 闭包 在第二个页面写一个闭包(要传的值是字符串, 整型, 字典) 1typealias InputClosureType = (String, Int, [String: String]) -&gt; Void 需要在第二个页面理创建一个闭包 1var backClosure: InputClosureType? 在点击事件里执行闭包 12345if self.backClosure != nil &#123; self.backClosure?("卢梦如", 24, ["name": "卢梦如"]) &#125; 在第一个页面里创建第二个页面的实例的地方对闭包传值 123456789secondVC.backClosure = &#123; (name: String, age: Int, dictionary: [String: String]) -&gt; Void in // 打印传过来的数据 print("\(name) is \(age) years", dictionary) &#125; 代理 在第二个页面里 声明一个代理 12345protocol SecondViewControllerDelegate: NSObjectProtocol &#123; func backValue(string: String, value: Int) &#125; 定义代理 1var delegate: SecondViewControllerDelegate? 在点击事件里执行代理 12345if self.delegate != nil &#123; delegate?.backValue(string: &quot;卢梦如&quot;, value: 24) &#125; 在第一个页面里面遵守代理, 然后设置代理 1secondVC.delegate = self 执行代理的方法 1234567func backValue(string: String, value: Int) &#123; // 打印传入的数据 print("\(string) is \(value)") &#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift 功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIScrollView]]></title>
    <url>%2F2016%2F11%2F28%2FUIScrollView%2F</url>
    <content type="text"><![CDATA[用Swift写的UIScrollView文本 UIScrollView 创建 UIScrollView 1let scrollView = UIScrollView(frame: self.view.bounds) 设置 UIScrollView 的大小 1scrollView.contentSize = CGSize(width: self.view.frame.width * 4, height: self.view.frame.height) 设置 UIScrollView 的偏移位置 1scrollView.contentOffset = CGPoint(x: self.view.frame.width, y: 0) 设置是否反弹 1scrollView.bounces = true 设置是否分页 1scrollView.isPagingEnabled = true 设置是否滚动 1scrollView.isScrollEnabled = true 设置 indicator( 滚动条的颜色 ) 风格 1scrollView.indicatorStyle = UIScrollViewIndicatorStyle.white 设置 内容的边缘和 Indicators 边缘 1scrollView.contentInset = UIEdgeInsetsMake(0, 50, 0, 0) 手势放大缩小 .minimumZoomScale = 0.1 最小比例 .maximumZoomScale = 3 最大比例 123scrollView.minimumZoomScale = 0.1scrollView.maximumZoomScale = 3 设置代理 1scrollView.delegate = self 添加到父视图 1self.view.addSubview(scrollView) 代理方法 返回一个放大或者缩小的视图 123func viewForZooming(in scrollView: UIScrollView) -&gt; UIView? &#123; &#125; 开始放大或者缩小 123func scrollViewWillBeginZooming(_ scrollView: UIScrollView, with view: UIView?) &#123; &#125; 缩放结束时 123func scrollViewDidEndZooming(_ scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat) &#123; &#125; 视图已经放大或缩小 123func scrollViewDidZoom(_ scrollView: UIScrollView) &#123;&#125; 滑动到顶部时调用该方法 12345func scrollViewDidScrollToTop(_ scrollView: UIScrollView) &#123; print("顶部") &#125; 正在滑动 12345func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; print("正在滑动...") &#125; 开始拖动 12345func scrollViewWillBeginDragging(_ scrollView: UIScrollView) &#123; print("开始拖动") &#125; 结束拖动 12345func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) &#123; print("结束拖动") &#125; 开始减速 12345func scrollViewWillBeginDecelerating(_ scrollView: UIScrollView) &#123; print("开始减速...") &#125; 减速停止 12345func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) &#123; print("减速停止") &#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift 控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github pages 搭建个人博客]]></title>
    <url>%2F2016%2F09%2F22%2FHexo-Github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[把搭建博客的每一步都记录下来. Github hexo可以根据Hexo文档来开发,这里都有详细的教程. 准备工作 安装Node.js 安装Git 安装hexo 在终端里面执行以下代码安装 npm: 1npm install 安装完之后在分别终端里面输入: 123git --versionnode -vnpm -v 看到各个插件的版本之后才说明是准备工作完成. 开始搭建博客 找一个自己喜欢的路径,创建一个的文件夹Hexo,在终端里打开这个Hexo 文件夹,然后执行: 1hexo init 到现在就安装好了所有的东西 继续在打开的Hexo文件的终端分别输入: 12hexo generatehexo server 也可以简写为: 12hexo ghexo s hexo generate 是生成静态页面, hexo server 是启动本地调试. 完成之后打开浏览器输入网址 localhost:4000,就可以看到本地已经出现hexo初始的博客了 在Github上面创建新的仓库 点击 New repository 进入创建仓库界面,新建的仓库名字格式必须是:xxxx.github.io,如下图 创建 SSH keys 在终端里面输入 1cd ~/.ssh 查看此文件夹里面是否有 id _rsa id _rsa.pub 两个文件,如果有的话就说明已经有 SSH keys 了 如果没有的话就自己生成一个,终端里面输入你自己的邮箱: 1ssh-keygen -t rsa -C "your_email@example.com" 然后会出现 : 12Generating public/private rsa key pair.Enter file in which to save the key (/Users/you/.ssh/id_rsa): 意思是让你输入 SSH keys 的保存地址 直接回车就好,不用理会,然后会出现: 1Enter passphrase (empty for no passphrase): [Type a passphrase] 意思是让你输入密码,这个要记住,以后会用的到,创建成功之后他会提示你 SSH keys 保存到哪里,按照这个地址找到 id _rsa.pub. 这个就是 SSH key,用终端打开这个文件,然后拷贝里面的内容,最上面的那部分 为github仓库添加 SSH key,进入Github的设置里面,找到 SSH and GPG keys进入里面点击 New SSH key 把之前拷贝的内容放进去,然后确定就OK了. 在终端里面输入: 1ssh -T git@github.com 来测试链接是否成功. 它可能会出现一些乱七八糟的提示,最后是问你yes/no,就输入yes. 如果是: 1Enter passphrase for key '/c/Users/2000104591/.ssh/id_rsa': 输入之前让你记住的那个密码就行了. 最后提示你: 1Hi, 用户名/用户名.github.io! You've successfully authenticated, but GitHub does notprovide shell access. 这样就配置完毕了 配置 _config.yml 文件,在让你新建的 Hexo 目录下有个 _ config.yml 文件,打开他把里面的 deploy: 下的东西改为 1234deploy: type: git repository: https://github.com/xxxx/xxxx.github.io branch: master 配置完成以后,执行: 12hexo generate hexo deploy 如果报错: 1Error: Deployer not found : github 执行如下命令: 1npm install hexo-deployer-git --save 成功之后再试一次输入: 12hexo ghexo d 提示你成功之后你就可以打开xxxx.github.io来查看你的博客了.]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>